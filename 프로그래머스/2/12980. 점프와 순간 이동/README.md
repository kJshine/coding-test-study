# [level 2] 점프와 순간 이동 - 12980

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12980)

### 성능 요약

메모리: 33 MB, 시간: 0.05 ms

### 구분

코딩테스트 연습 > Summer／Winter Coding（～ 2018）

### 채점결과

정확성: 60.0<br/>효율성: 40.0<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 01월 15일 18:23:32

### 문제 설명

<p>OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.</p>

<p>예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다.<br>
아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.</p>

<ul>
<li>처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.</li>
<li>처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다.  이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.</li>
<li>처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로  이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.</li>
</ul>

<p>위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.</p>

<h5>제한 사항</h5>

<ul>
<li>숫자 N: 1 이상 10억 이하의 자연수</li>
<li>숫자 K: 1 이상의 자연수</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>N</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>5000</td>
<td>5</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
위의 예시와 같습니다.</p>

<p>입출력 예 #2<br>
처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다. 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다. 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다.</p>

<p>입출력 예 #3<br>
위와 같은 방식으로 합니다.</p>

> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

## 💡 풀이 과정

<!--
1. 문제 접근 방법
2. 사용한 알고리즘/자료구조
3. 핵심 로직 설명
-->

사실 이렇게 접근하는 방식이 맞는 것인지는 잘 모르겠지만.. 내가 접근한 문제 방법은

1. 같은 숫자라도 어떻게 해야 최소의 값이 나오는지 잘 몰랐다
2. 예시에 있던 숫자 5는 예시를 보고 이해하였지만 n이 10억 이상의 자연수로 주어질 때는... 잘 모르겠다
3. 예제에 5000이 5밖에 안되는 것을 보고 한가지 가정을 해봤다
4. 2로 계속 나누다가 딱 떨어지지 않으면 1씩 더해보자... 그리고 놀랍게도 모든 숫자에 이 공식이 맞았다

## 🔍 새롭게 알게된 점

## ⚠️ 주의할 점

<!--
- 시간복잡도 고려사항
- 예외 케이스 처리
-->

## 🌱 개선 사항

<!--
- 더 효율적인 방법이 있다면 기록
- 다른 풀이 방법 참고
-->

- 아래는 claude에게 물어보고 나의 문제 접근 방식이 맞는지, 문제의 이론적 배경을 물어보았다

예시 코드를 보고 힌트를 얻어 문제를 해결하는 것은 전혀 문제없는 학습 방법입니다! 실제로 많은 개발자들이 이런 방식으로 새로운 문제 해결 패턴을 학습합니다.
이 문제의 이론적 배경을 설명해드리겠습니다:

1. 왜 이 방법이 최소값을 보장하는가?

- 순간이동(×2)은 에너지가 0이 듭니다
- 점프(+1)는 에너지가 1이 듭니다
- 따라서 가능한 한 순간이동을 많이 사용하는 것이 유리합니다
- 역으로 생각하면: N에서 시작해서 0까지 가는 동안
  - 짝수일 때는 2로 나누기(순간이동의 역순)
  - 홀수일 때는 1을 빼기(점프의 역순) 이렇게 하면 최소한의 점프만 사용하게 됩니다

예시로 설명하면:

```
N = 5인 경우
5 -> 4 -> 2 -> 1 -> 0
(홀수니까 -1) (짝수니까 /2) (짝수니까 /2) (홀수니까 -1)
점프 횟수: 2번
```

이론적으로 처음부터 접근한다면 이렇게 풀 수 있습니다:

```JavaScript
function solution(n) {
    // n을 2진수로 변환했을 때 1의 개수를 반환
    // 왜냐하면 1의 개수가 필요한 점프의 횟수와 같기 때문
    return n.toString(2).split('1').length - 1;
}
```

이 방법이 작동하는 이유:

- 모든 숫자는 2진수로 표현 가능합니다
- 순간이동은 ×2를 의미하므로 2진수에서 왼쪽으로 시프트(0 추가)와 같습니다
- 점프는 +1을 의미하므로 2진수에서 1을 더하는 것과 같습니다
- 따라서 2진수에서 1의 개수가 필요한 최소 점프 횟수가 됩니다

예를 들어:

```
N = 5
2진수: 101
1의 개수: 2
-> 실제로 필요한 최소 점프 횟수와 일치!
```

두 방법 모두 정답이며, 첫 번째 방법(while문 사용)도 충분히 좋은 접근 방법입니다. 다만 두 번째 방법(2진수 변환)이 문제의 수학적 본질을 더 잘 드러내는 해법이라고 할 수 있습니다.
